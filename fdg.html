<html lang="en">
    <head>
       <meta charset="utf-8">
       <meta name="viewport" content="width=device-width, initial-scale=1">
       <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
       <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
        <script src="config.js"></script>


        <title>Force-Directed Graph Demo</title>
        <link rel="stylesheet" type="text/css" href="fdg.css"></link>
    </head>
    <body onkeydown="handleKeyDown();">
        <script src="fdg_init.js"></script>
        <script src="fdg_node.js"></script>
        <script src="fdg_link.js"></script>
        <script src="fdg_events.js"></script>
        <script src="fdg_sim.js"></script>

        <script>


async function LoadData() {
    // this queues both promises (and their associated "then" statements) via parallel threads

    const nodePromise = supabaseClient
        .from("nodes")
        .select("*");

let { data: nodelist, error } = await nodePromise; 

      if (error) {
        console.error(error);
        return;
      }

       console.log(nodelist); 
       nodelist.forEach(Node.AppendDatum);
       AppendShapes( nodelist );


const linkPromise = supabaseClient
        .from("edges")
        .select("*");

let { data: linklist, error: link_error } = await linkPromise; 

      if (link_error) {
        console.error(link_error);
        return;
      }

       linklist.forEach(AppendLinkDatum);
       AppendLines( linklist );

    // async means even LoadData() runs in a new thread. Control immediately returns
    // only within this function can we reliably delay AfterLoad() until 
    AfterLoad();
}


//-------------------------------------------------------------------------------
// final init steps that have to wait until nodes AND links are both populated 
function AfterLoad() {
    // collect all immediate links into/out of each node regardless of type
    nodes.forEach( d => { 
        d.inLinks  = links.filter( x => ( x.TO_NODE_ID   == d.NODE_ID ) ); 
        d.outLinks = links.filter( x => ( x.FROM_NODE_ID == d.NODE_ID ) );
    } );
    // these will be used to manage interactive stacking & unstacking
    // when stacked, tail nodes must be excluded from the force model
    // i.e. the force simulation uses only the leading child node
    // ideally we'd still like all links to influence the animation. Problem: the stacked nodes 
    // stacking a node means removing it from the force model AND letting all its clicks 'through to the keeper'
    // for any node we must call split(1) to get the head of its list
    nodes.filter(IsFrameShape).forEach( gn => {
        ChildrenOf(gn).forEach( lnk => {
            lnk.target = gn.inLinks[0].source;
            lnk.strength = 100;
            })
        });
    console.log(links);
    AppendFrameShapes(); // don't forget the parentheses!

    // 'null' simulation - lazy one-time pragma just to ensure inactive nodes are correctly registered with d3
    simPassive = d3.forceSimulation(nodes.filter(NodeScope)).stop();

    RunSim();

} // end AfterLoad()


//-------------------------------------------------------------------------------


LoadData(); // async means control is returned immediately, before any data 
// anything else we can do now that doesn't depend on nodes & links?

</script>
</body>
</html>
