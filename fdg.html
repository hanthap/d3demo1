<html lang="en">
    <head>
       <meta charset="utf-8">
       <meta name="viewport" content="width=device-width, initial-scale=1">
       <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
       <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
        <script src="config.js"></script>


        <title>Force-Directed Graph Demo</title>
        <link rel="stylesheet" type="text/css" href="fdg.css"></link>
    </head>
    <body onkeydown="handleKeyDown();">
        <script src="fdg_init.js"></script>
        <script src="fdg_graph.js"></script>
        <script src="fdg_node.js"></script>
        <script src="fdg_frame.js"></script>
        <script src="fdg_link.js"></script>
        <script src="fdg_events.js"></script>
        <script src="fdg_sim.js"></script>

        <script>


async function LoadData() {
    // this queues both promises (and their associated "then" statements) via parallel threads

    const nodePromise = supabaseClient
        .from("nodes")
        .select("*");

let { data: nodelist, node_error } = await nodePromise; 

      if (node_error) {
        console.error(node_error);
        return;
      }

//       console.log(nodelist); 



       nodelist.forEach(Node.AppendDatum);
       nodes = nodelist;

// before calling Link.AppendDatum() we need to enable Node.GetFromID()
       mapNodes = new Map ( nodes.map( x => ( [x.NODE_ID, x ]) ) );


const linkPromise = supabaseClient
        .from("edges")
        .select("*");

let { data: linklist, error: link_error } = await linkPromise; 

      if (link_error) {
        console.error(link_error);
        return;
      }
      links = linklist;
       links.forEach(Link.AppendDatum);


    // async means even LoadData() runs in a new thread. Control immediately returns
    // only within this function can we reliably delay AfterLoad() until 
    AfterLoad();
}


//-------------------------------------------------------------------------------
// final init steps that have to wait until nodes AND links are both populated 
function AfterLoad() {
    
    // collect all immediate links into/out of each node regardless of type
    nodes.forEach( d => { 
        d.inLinks  = links.filter( x => ( x.TO_NODE_ID   == d.NODE_ID ) ); 
        d.outLinks = links.filter( x => ( x.FROM_NODE_ID == d.NODE_ID ) );
    } );
 
    nodes.filter(Node.ShowAsFrame).forEach( gn => {
        ChildrenOf(gn).forEach( lnk => {
            lnk.target = gn.inLinks[0].source;
            lnk.strength = 100;
            })
        });

    // precompute & store lists
    Graph.CacheAllDescendants();    // descendants, per node
    Graph.CacheAllExclusiveNodes(); // circles and frames in scope of active_exclusion force
    Graph.CacheSortedNodes();       // z-order of nested frames

    AppendShapes(); 
    AppendFrameShapes(); 
    AppendLines();

    // 'null' simulation - lazy one-time pragma just to ensure inactive nodes are correctly registered with d3
    simPassive = d3.forceSimulation(nodes.filter(NodeScope)).stop();

    RunSim();

     // debug
    pqr = Node.GetFromID( 'PQR' )
    pqr_kids = ChildrenOf(pqr)
    pqr_desc = VisibleDescendantsOf(pqr)
  //  console.log(pqr_desc)
  //  console.log(pqr_kids)
    msn = Node.GetFromID( 'MSN' )
    console.log(msn);
//    mno_sel = Node.GetSelection( mno, 'rect' );
//    console.log(mno_sel);
//    mno_rect = mno_sel._groups[0][0];
//    console.log(mno_rect);  
//    console.log(mno_rect.getBBox());  // returns SVGRect { x: ..., y: ..., width: ..., height: ... }
 
//   console.log(flist);
   console.log(sorted_nodes);


} // end AfterLoad()


//-------------------------------------------------------------------------------


LoadData(); // async means control is returned immediately, before any data 
// anything else we can do now that doesn't depend on nodes & links?


</script>
</body>
</html>
