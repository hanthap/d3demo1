<html lang="en">
    <head>
       <meta charset="utf-8">
       <meta name="viewport" content="width=device-width, initial-scale=1">
       <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
       <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
        <script src="config.js"></script>


        <title>Force-Directed Graph Demo</title>
        <link rel="stylesheet" type="text/css" href="fdg.css"></link>
    </head>
    <body onkeydown="handleKeyDown();">
        <script src="fdg_init.js"></script>
        <script src="fdg_graph.js"></script>
        <script src="fdg_node.js"></script>
        <script src="fdg_frame.js"></script>
        <script src="fdg_link.js"></script>
        <script src="fdg_label.js"></script>
        <script src="fdg_events.js"></script>
        <script src="fdg_sim.js"></script>

        <script>


async function LoadData() {
    // this queues both promises (and their associated "then" statements) via parallel threads

    const nodePromise = supabaseClient
        .from("nodes")
        .select("*");

    let { data: nodelist, node_error } = await nodePromise; 

      if (node_error) {
        console.error(node_error);
        return;
      }

       nodelist.forEach(Node.AppendDatum);
       nodes = nodelist;

    // before calling Link.AppendDatum() we need to enable Node.GetFromID()
       mapNodes = new Map ( nodes.map( x => ( [x.NODE_ID, x ]) ) );


    const linkPromise = supabaseClient
        .from("edges")
        .select("*");

    let { data: linklist, error: link_error } = await linkPromise; 

    if (link_error) {
        console.error(link_error);
        return;
      }
    links = linklist;
    links.forEach(Link.AppendDatum);

    AfterLoad();
}


//-------------------------------------------------------------------------------
// final init steps that have to wait until nodes AND links are both populated 
function AfterLoad() {
    
    // collect all immediate links into/out of each node regardless of type
    nodes.forEach( d => { 
        d.inLinks  = links.filter( x => ( x.TO_NODE_ID   == d.NODE_ID ) ); 
        d.outLinks = links.filter( x => ( x.FROM_NODE_ID == d.NODE_ID ) );
    } );

// store true source/target references in each link
links.forEach( d => {
    d.true_source = d.source;
    d.true_target = d.target;
} );

    // precompute & store lists
    Graph.CacheAllDescendants();    // descendants, per node
    Graph.CacheAllExclusiveNodes(); // circles and frames in scope of active_exclusion force
    Graph.CacheSortedNodes();       // z-order of nested frames

    AppendShapes(); 
    AppendFrameShapes(); 
    AppendLines();
    AppendLabels();


    // 'null' simulation - lazy one-time pragma just to ensure inactive nodes are correctly registered with d3
    simPassive = d3.forceSimulation(nodes.filter(NodeScope)).stop();

    RunSim(); 

} // end AfterLoad()


//-------------------------------------------------------------------------------


LoadData(); // async means control is returned immediately, before any data 
// anything else we can do now that doesn't depend on nodes & links?


</script>
</body>
</html>
